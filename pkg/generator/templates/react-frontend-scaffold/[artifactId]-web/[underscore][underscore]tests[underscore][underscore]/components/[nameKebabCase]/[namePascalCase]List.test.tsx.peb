import { fireEvent, render, screen, waitFor } from '@testing-library/react'
import { {{ namePascalCase }}List } from '../../../src/components/app/{{ nameKebabCase }}/{{ namePascalCase }}List'
import { Client, Provider } from 'urql'
import { fromValue } from 'wonka'

describe('{{ namePascalCase }}List', () => {
  const {{ nameCamelCase }} = {
    id: '1'{%for field in fields%},
    {{field.fieldNameCamelCase}}: {{field.fieldFrontendTestValue}}{%endfor%}
  }

  it('forwards to {{ nameCamelCase }} page on Show', () => {
    const executeQuery = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation: jest.fn(),
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    expect(screen.getByText('Show')).toHaveAttribute('href', '/{{ namePluralKebabCase }}/1')
  })

  it('renders entries when data is fetched', () => {
    const executeQuery = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      }),
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation: jest.fn(),
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    ){%for field in fields%}
    expect(screen.getAllByText('' + {{ nameCamelCase }}.{{ field.fieldNameCamelCase }}).length).not.toBe(0){%endfor%}
  })

  it('opens modal when edit is clicked', () => {
    const executeQuery = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    expect(screen.queryByText('Edit {{ namePascalCase }}')).toBeNull()
    fireEvent(
      screen.getByText('Edit'),
      new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
      })
    )
    expect(screen.queryByText('Edit {{ namePascalCase }}')).not.toBeNull()
  })

  it('closes modal when Save is clicked', async () => {
    const executeQuery = jest.fn()
    const executeMutation = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      })
    )
    executeMutation.mockReturnValue(
      fromValue({
        data: {},
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation,
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    fireEvent(
      screen.getByText('Edit'),
      new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
      })
    )
    await waitFor(() => {
      fireEvent(
        screen.getByText('Save'),
        new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
        })
      )
    })
    expect(screen.queryByText('Edit {{ namePascalCase }}')).toBeNull()
  })

  it('closes modal when Save is clicked', async () => {
    const executeQuery = jest.fn()
    const executeMutation = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      })
    )
    executeMutation.mockReturnValue(
      fromValue({
        data: {},
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation,
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    fireEvent(
      screen.getByText('Edit'),
      new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
      })
    )
    await waitFor(() => {
      fireEvent(
        screen.getByText('Cancel'),
        new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
        })
      )
    })
    expect(screen.queryByText('Edit {{ namePascalCase }}')).toBeNull()
  })

  it('calls mutation when Delete is clicked and confirmed', async () => {
    jest.spyOn(window, 'confirm').mockReturnValueOnce(true)
    const executeQuery = jest.fn()
    const executeMutation = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      }),
    )
    executeMutation.mockReturnValue(
      fromValue({
        data: {},
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation,
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    await waitFor(() => {
      fireEvent(
        screen.getByText('Delete'),
        new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
        })
      )
    })
    expect(mockClient.executeMutation).toBeCalled()
  })

  it('does not call mutation when Delete is clicked and not confirmed', async () => {
    jest.spyOn(window, 'confirm').mockReturnValueOnce(false)
    const executeQuery = jest.fn()
    const executeMutation = jest.fn()
    executeQuery.mockReturnValue(
      fromValue({
        data: {
          {{ namePluralCamelCase }}: [{{ nameCamelCase }}],
        },
      })
    )
    executeMutation.mockReturnValue(
      fromValue({
        data: {},
      })
    )
    const mockClient: Partial<Client> = {
      executeQuery,
      executeMutation,
      executeSubscription: jest.fn(),
    }
    render(
      <Provider value={mockClient as Client}>
        <{{ namePascalCase }}List />
      </Provider>
    )
    await waitFor(() => {
      fireEvent(
        screen.getByText('Delete'),
        new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
        })
      )
    })
    expect(mockClient.executeMutation).not.toBeCalled()
  })
})
