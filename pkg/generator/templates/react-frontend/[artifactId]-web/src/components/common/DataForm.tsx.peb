import { useState } from 'react'
import { LoadingIndicator } from '@components/common/LoadingIndicator'
import { ErrorMessage } from '@components/common/ErrorMessage'

export enum DataFormFieldType {
  RELATIONAL,
  RELATIONAL_OPTIONAL,
  STRING,
  STRING_OPTIONAL,
  TEXT,
  TEXT_OPTIONAL,
  DATE,
  DATE_OPTIONAL,
  DATETIME,
  DATETIME_OPTIONAL,
  INT,
  INT_OPTIONAL,
  BOOLEAN,
  BOOLEAN_OPTIONAL,
}

export interface DataFormFieldOption {
  label: string
  value: string
}

export interface DataFormField<T> {
  name: string
  label?: string
  options?: DataFormFieldOption[]
  type: DataFormFieldType
  hidden?: boolean
  value: (data: T) => string | number | undefined
}

export interface DataFormProps<T> {
  fields: DataFormField<T>[]
  errorMessage?: string
  fetching?: boolean
  defaultValue: T
  onSubmit: (result: T) => void
  onCancel: () => void
}

function createFormElement<T>(
  field: DataFormField<T>,
  value: string | number | undefined,
  onUpdate: (value: string | number | undefined) => void
) {
  switch (field.type) {
    case DataFormFieldType.RELATIONAL:
      return (
        <select
          name={field.name}
          required
          defaultValue={value}
          onChange={(event) => onUpdate(event.target.value)}
        >
          <option value="" />
          {field.options?.map((option) => (
            <option
              key={option.value}
              value={option.value}
              onSelect={() => onUpdate(option.value)}
            >
              {option.label}
            </option>
          ))}
        </select>
      )
    case DataFormFieldType.RELATIONAL_OPTIONAL:
      return (
        <select
          name={field.name}
          defaultValue={value}
          onChange={(event) => onUpdate(event.target.value)}
        >
          {field.options?.map((option) => (
            <option
              key={option.value}
              value={option.value}
              onSelect={() => onUpdate(option.value)}
            >
              {option.label}
            </option>
          ))}
        </select>
      )
    case DataFormFieldType.STRING:
      return (
        <input
          name={field.name}
          type="text"
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.STRING_OPTIONAL:
      return (
        <input
          name={field.name}
          type="text"
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
    case DataFormFieldType.TEXT:
      return (
        <textarea
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.TEXT_OPTIONAL:
      return (
        <textarea
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
    case DataFormFieldType.DATE:
      return (
        <input
          type="date"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.DATE_OPTIONAL:
      return (
        <input
          type="date"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
    case DataFormFieldType.DATETIME:
      return (
        <input
          type="datetime"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.DATETIME_OPTIONAL:
      return (
        <input
          type="datetime"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
    case DataFormFieldType.INT:
      return (
        <input
          type="number"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.INT_OPTIONAL:
      return (
        <input
          type="number"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
    case DataFormFieldType.BOOLEAN:
      return (
        <input
          type="checkbox"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
          required
        />
      )
    case DataFormFieldType.BOOLEAN_OPTIONAL:
      return (
        <input
          type="checkbox"
          name={field.name}
          defaultValue={value}
          onChange={(e) => onUpdate(e.target.value)}
        />
      )
  }
}

function LoadedDataForm<T>(props: DataFormProps<T>) {
  const [formData, setFormData] = useState<T>(props.defaultValue)
  return (
    <form
      role="form"
      onSubmit={(e) => {
        e.preventDefault()
        props.onSubmit(formData)
      }}
    >
      <table>
        <tbody>
          {props.fields
            .filter((field) => !field.hidden)
            .map((field) => (
              <tr key={field.name}>
                <td>{field.label}</td>
                <td>
                  {createFormElement(
                    field,
                    formData && field.value(formData),
                    (v) => {
                      const newValue = { ...formData, [field.name]: v }
                      setFormData(newValue)
                    }
                  )}
                </td>
              </tr>
            ))}
          <tr>
            <td />
            <td>
              <button>Save</button>
              <button type="button" onClick={props.onCancel}>
                Cancel
              </button>
            </td>
          </tr>
        </tbody>
      </table>
    </form>
  )
}

export function DataForm<T>(props: DataFormProps<T>) {
  if (props.fetching) {
    return <LoadingIndicator />
  }
  if (props.errorMessage) {
    return <ErrorMessage message={props.errorMessage} />
  }
  return <LoadedDataForm {...props} />
}
