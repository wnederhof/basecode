---
layout: page
title: Backend Design
permalink: /design/backend
parent: Project Structure and Design
nav_order: 1
---
## Code Generated for the Backend
CrudCodeGen is highly opiniated about the code that it generates.
This section discusses the various considerations that have led to its design.

### Kotlin and Spring Boot
Backend code generated by CrudCodeGen uses
Spring Boot and Kotlin. Spring Boot provides dependency injection with
a lot of pre-configured capabilities out-of-the-box
and is widely used for enterprise and web applications.
At the same time, Kotlin is a popular, easy to learn,
expressive programming language for the JVM.
As such, the powerful combination of Spring Boot and Kotlin provides
a highly productive software environment with a massive ecosystem.

### Persistence
CrudCodeGen uses Spring Data JDBC. Spring Data JDBC was chosen over Spring
Data JPA because Spring Data JDBC is much simpler, yet almost as
powerful for most use cases.

Most notably, Spring Data JDBC does not use a cache, and is therefore much
easier to reason about.
Furthermore, Spring Data JDBC is syntactically very similar to Spring Data JPA, and
so are its capabilities.

The caveat, however, is that the database needs to be called more often because
of the lack of caching (which is fine in most cases), and that Spring Data JDBC
does not support many-to-one and many-to-many relationships.
Nevertheless, the latter is only a minor issue as explained in
[this](https://www.youtube.com/watch?v=AnIouYdwxo0) video.

### Decoupled Architecture
CrudCodeGen packages code by features (`posts`, `comments`, etc.)
instead of by layer (`controller`, `service`, etc.). This has the
benefit that the packages are more cohesive and easier to navigate.

This package structure, however, may also lead to confusion. For instance,
given a blog with `posts` and `comments`, where `posts` have a 1-N
relationship with `comments`.
When building a class that calls methods from both `posts` and `comments`,
it may be unclear whether the class should reside in the `posts` or in
the `comments` package.

Code generated by CrudCodeGen ensures that the information flow
between different packages is always unidirectional by utilizing
events and event listeners. Other than decreased coupling,
this also serves as a guideline for where classes should reside.

Given a one-to-many relationship,
CrudCodeGen always generates code in such a way that the classes
in the "many" part of the relationship depend on the classes
in the "one" part, but never the other way around.
As for the example above, since `comments` depend on `posts`,
classes that use both `posts` and `comments` should reside in `comments`.

In fact, by applying this unidirectional information flow consistently,
it also means that if the package `comments` is removed (together
with the GraphQL schema definitions), the application stills works,
minus the comments. This in itself is already quite powerful, because
it means that features can be developed in isolation.

Consistently making sure that the flow of data is
unidirectional leads to a highly decoupled architecture, which is probably
the main strength of CrudCodeGen. In fact, this has been the main
motivation for creating CrudCodeGen in the first place.

### GraphQL
Most traditional web applications provide a REST API for allowing the
frontend to communicate with the backend. It may therefore come as a
surprise that CrudCodeGen does not support generating REST controllers.

Before GraphQL was introduced, a change in the frontend would often
require a change on the backend. For instance, if the frontend
would want to show a list of comments for a blog post instead of
just the blog post, either a new endpoint would have to be created,
or multiple API calls would have to be fired.

Multiple API consumers (e.g. mobile, microservices, etc.) with
different use cases would often lead to a wilderness of API endpoints,
different "DTOs" per use case and data transformers also known as "mappers".
Even worse, as soon as relationships would come into play (e.g. having
the controller of `/posts` also provide a `comments` field),
a unidirectional flow of data between packages would simply be off the table.

Using GraphQL, the consumer specifies the shape of the data it needs.
Whether the consumer just requires
`posts` with only their `title`, or `posts` with `comments`, no changes are
required from the producer side. This means that mappers, DTOs and
endpoints per use case are no longer needed.

More importantly, we can still guarantee a unidirectional flow,
since we only need to specify a "resolver" for this relationship (in the
`comments` package) and a GraphQL schema extension (in a separate
`comments.graphqls` file).

Finally, GraphQL allows loose coupling between the frontend and the backend,
since changes to the frontend data requirements do not have
to result in changes on the backend. In theory, one could build
a mobile app with a subset of the web app's features without
*any* changes on the backend.

Nevertheless, there is nothing wrong with using REST controllers.
And since CrudCodeGen is just a code generator, it will always
remain available to the developer. CrudCodeGen just
doesn't support the generation of REST controllers, simply because
GraphQL is a much better fit in most cases.

[comment]: <> (TODO... Foreign Key constraints, testing easier, Aggregates are separate, isolated concepts.)
