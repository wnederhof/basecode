# Design Considerations

## Code Generated for the Backend
Codebeaver is highly opiniated about the code that it generates.
This section discusses the various considerations that have led to its design.

### Kotlin and Spring Boot
Backend code generated by Codebeaver uses 
Spring Boot and Kotlin. Spring Boot has a large ecosystem
and is widely used for enterprise and web applications.
At the same time, Kotlin is a widely used, easy to learn,
expressive programming language that runs on the JVM.
The powerful combination of Spring Boot and Kotlin allows for
productive software development without worrying about potential
deal-breaking deficiencies of the ecosystem.

### Persistence
Codebeaver uses Spring Data JDBC. Spring Data JDBC was chosen over Spring
Data JPA because Spring Data JDBC is much simpler, yet almost as
powerful for most use cases.

Most notably, Spring Data JDBC does not use a cache, and is therefore much
simpler to operate.
Furthermore, Spring Data JDBC is syntactically very similar to Spring Data JPA, and
so are its capabilities.

Spring Data JDBC does not support many-to-one relationships, however,
as explained in [this](https://www.youtube.com/watch?v=AnIouYdwxo)
video.

### Decoupled Architecture
Codebeaver packages code by features (`posts`, `comments`, etc.)
instead of by layer (`controller`, `service`, etc.), which has the 
benefit that the packages are more cohesive and easier to navigate.

This package structure, however, may also lead to confusion. For instance,
given a blog with `posts` and `comments`, where `posts` have a 1-N
relationship with `comments`.
When building a class that calls methods from both `posts` and `comments`,
it may be unclear whether the class should reside in the `posts` or in
the `comments` package.

Code generated by Codebeaver ensures that the information flow
between different packages is always unidirectional by utilizing
events and event listeners. Other than increased decoupling,
this also serves as a guideline for where classes should reside.

Given a one-to-many relationship,
Codebeaver always generates code in such a way that the classes
in the "many" part of the relationship depend on the classes
in the "one" part, but never the other way around.
As for the example above, since `comments` depend on `posts`,
classes that use both `posts` and `comments` should reside in `comments`.

In fact, by applying this unidirectional information flow consistently,
it also means that if the package `comments` is removed (together
with the GraphQL schema definitions), the application stills works,
minus the comments.

This decoupled architecture is probably the main strength of Codebeaver.
In fact, this has been the main motivation for creating Codebeaver
in the first place.

### GraphQL
Most traditional web applications provide a REST API for allowing the
frontend communicate with the backend. It may therefore come as a
surprise that Codebeaver does not support generating REST controllers.

Before GraphQL was introduced, a change in the frontend would often
require a change in the backend. For instance, if the frontend
would want to show a list of comments for a blog post instead of
just the blog post, either a new endpoint would have to be created,
or multiple API calls would have to be fired.

Given multiple API consumers (e.g. mobile, microservices, etc.) with
different use cases would often lead to a wilderness of API endpoints,
different "DTOs" per use case and data transformers, also known as "mappers". 
Even worse, as soon as relationships would come into play (e.g. having
the controller of `/posts` also provide a `comments` field),
a unidirectional flow of data between packages is simply off the table.

GraphQL is less painful in that regard. Using GraphQL, the consumer
specifies the shape of the data it needs. Whether the consumer just requires
`posts` with their title or `posts` with `comments`, no changes are
required from the producer side. This means that mappers, DTOs and
endpoints per use case are no longer needed. 

Furthermore, on the back
