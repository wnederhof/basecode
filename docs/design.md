# Design Considerations
## Code Generated for the Backend
Codebeaver is highly opiniated about the code that it generates.
This section discusses the various considerations that have led to its design.

### Kotlin and Spring Boot
Backend code generated by Codebeaver uses 
Spring Boot and Kotlin. Spring Boot provides dependency injection with
a lot of pre-configured capabilities out-of-the-box
and is widely used for enterprise and web applications.
At the same time, Kotlin is a popular, easy to learn,
expressive programming language for the JVM.
As such, the powerful combination of Spring Boot and Kotlin provides
a highly productive software environment with a massive ecosystem.

### Persistence
Codebeaver uses Spring Data JDBC. Spring Data JDBC was chosen over Spring
Data JPA because Spring Data JDBC is much simpler, yet almost as
powerful for most use cases.

Most notably, Spring Data JDBC does not use a cache, and is therefore much
easier to reason about.
Furthermore, Spring Data JDBC is syntactically very similar to Spring Data JPA, and
so are its capabilities.

The caveat, however, is that the database needs to be called more often because
of the lack of caching (which is fine in most cases), and that Spring Data JDBC
does not support many-to-one and many-to-many relationships.
Nevertheless, the latter is only a minor issue as explained in
[this](https://www.youtube.com/watch?v=AnIouYdwxo0) video.

### Decoupled Architecture
Codebeaver packages code by features (`posts`, `comments`, etc.)
instead of by layer (`controller`, `service`, etc.). This has the 
benefit that the packages are more cohesive and easier to navigate.

This package structure, however, may also lead to confusion. For instance,
given a blog with `posts` and `comments`, where `posts` have a 1-N
relationship with `comments`.
When building a class that calls methods from both `posts` and `comments`,
it may be unclear whether the class should reside in the `posts` or in
the `comments` package.

Code generated by Codebeaver ensures that the information flow
between different packages is always unidirectional by utilizing
events and event listeners. Other than decreased coupling,
this also serves as a guideline for where classes should reside.

Given a one-to-many relationship,
Codebeaver always generates code in such a way that the classes
in the "many" part of the relationship depend on the classes
in the "one" part, but never the other way around.
As for the example above, since `comments` depend on `posts`,
classes that use both `posts` and `comments` should reside in `comments`.

In fact, by applying this unidirectional information flow consistently,
it also means that if the package `comments` is removed (together
with the GraphQL schema definitions), the application stills works,
minus the comments. This in itself is already quite powerful.

Consistently making sure that the flow of data is
unidirectional leads to a highly decoupled architecture, which is probably
the main strength of Codebeaver. In fact, this has been the main
motivation for creating Codebeaver in the first place.

### GraphQL
Most traditional web applications provide a REST API for allowing the
frontend to communicate with the backend. It may therefore come as a
surprise that Codebeaver does not support generating REST controllers.

Before GraphQL was introduced, a change in the frontend would often
require a change on the backend. For instance, if the frontend
would want to show a list of comments for a blog post instead of
just the blog post, either a new endpoint would have to be created,
or multiple API calls would have to be fired.

Multiple API consumers (e.g. mobile, microservices, etc.) with
different use cases would often lead to a wilderness of API endpoints,
different "DTOs" per use case and data transformers also known as "mappers". 
Even worse, as soon as relationships would come into play (e.g. having
the controller of `/posts` also provide a `comments` field),
a unidirectional flow of data between packages would simply be off the table.

Using GraphQL, the consumer specifies the shape of the data it needs.
Whether the consumer just requires
`posts` with only their `title`, or `posts` with `comments`, no changes are
required from the producer side. This means that mappers, DTOs and
endpoints per use case are no longer needed. 

More importantly, we can still guarantee a unidirectional flow,
since we only need to specify a "resolver" for this relationship (in the
`comments` package) and a GraphQL schema extension (in a separate
`comments.graphqls` file).

Finally, GraphQL allows loose coupling between the frontend and the backend,
since changes to the frontend data requirements do not have
to result in changes on the backend. In theory, one could build
a mobile app with a subset of the web app's features without
*any* changes on the backend.

Nevertheless, there is nothing wrong with using REST controllers.
And since Codebeaver is just a code generator, it will always
remain available to the developer. Codebeaver just
doesn't support the generation of REST controllers, simply because
GraphQL is a much better fit in most cases.

[comment]: <> (TODO... Foreign Key constraints, testing easier, Aggregates are separate, isolated concepts.)

## Code Generated for the Frontend
### Frontend technology
Traditional web applications, in contrast to SPAs, are often rendered on the
server with Javascript "sprinkled" on top of it.
The programming model of traditional web applications is often much
simpler than that of SPAs, since it does not have to deal with loading data from the
server, client-side state management, client-side routing, SSR, etc.,
since the data is immediately present while generating the html.

Single Page Applications, however, often feel more responsive than traditional
web applications. Although libraries such as Turbolinks make traditional
web applications feel as responsive as SPAs, "sprinkling" Javascript
over the traditional application only takes you so far.

Recent developments, such as Nuxt.JS and GraphQL, have made it much easier to
create a SPA than a traditional web application.
While the client still needs to ask for data to the server, Nuxt.JS already
takes care of routing and SSR, and the backend comes decoupled from
the backend due to GraphQL.

Especially since the frontend and backend are dependent on very different
features (e.g. a frontend page may show both an activity feed and a list of posts at the same time,
which may be entirely different features on the backend concepts with no dependencies between them),
it is not such a bad idea to decouple them.

Furthermore, when an application would have to support a new consumer, such
as a mobile app, no changes need to be made to the backend, whereas
this may require a brand new API and lots of refactorings for traditional web applications.

For these reasons, Codebeaver does not render HTML on the backend server and physically
separates the backend from the frontend. By combining the best tools available
in the industry, building a separate frontend and connecting it through an API
takes a similar amount of effort as it would take for a similar traditional web application. 

As for the choice of the frontend framework, the main question was whether to choose
Angular, React and Vue.js. Codebeaver uses Vue.js since it is the most productive
web technology, and feels most natural when coming from building traditional web applications.
Furthermore, Vue.js felt more productive than both React and Angular and has a shallower
learning curve. The ecosystem of Vue.js is similar to React's ecosystem, and has
become the most popular frontend library of the three on Github.
When combining Vue.js with Nuxt.js, SSR, routing, code splitting, asset delivery and a lot more
is taken care of without any additional boilerplate code. As such, Codebeaver
uses Nuxt.js as the frontend framework of choice.
