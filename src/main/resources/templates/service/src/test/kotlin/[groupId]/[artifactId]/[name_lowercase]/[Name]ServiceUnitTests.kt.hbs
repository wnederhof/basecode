package {{ groupId }}.{{ artifactId }}.{{ name_lowercase }}
{{#each fields}}{{#if fieldRelationship}}
import {{ groupId }}.{{ artifactId }}.{{ fieldType_lowercase }}.{{ FieldType }}Service{{/if}}{{/each}}
import {{ groupId }}.{{ artifactId }}.{{ name_lowercase }}.{{ Name }}Fixtures.{{ NAME }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ name_lowercase }}.{{ Name }}Fixtures.CREATE_{{ NAME }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ name_lowercase }}.{{ Name }}Fixtures.{{ NAME }}_FIXTURE_WITH_ID_1{{#each fields}}{{#if fieldRelationship}}
import {{ groupId }}.{{ artifactId }}.{{ fieldType_lowercase }}.{{ FieldType }}Fixtures.{{ FIELD_TYPE }}_FIXTURE_WITH_ID_1{{/if}}{{/each}}
import com.nhaarman.mockitokotlin2.inOrder
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.springframework.context.ApplicationEventPublisher{{#if hasRelations}}
import org.junit.jupiter.api.assertThrows
import com.nhaarman.mockitokotlin2.times{{/if}}
import java.util.*

@ExtendWith(MockitoExtension::class)
internal class {{ Name }}ServiceUnitTests {

    @Mock
    private lateinit var applicationEventPublisher: ApplicationEventPublisher

    @Mock
    private lateinit var {{ name }}Repository: {{ Name }}Repository
{{#each fields}}{{#if fieldRelationship}}
    @Mock
    private lateinit var {{ fieldType }}Service: {{ FieldType }}Service
{{/if}}{{/each}}
    @InjectMocks
    private lateinit var {{ name }}Service: {{ Name }}Service

    @Test
    fun `findAll returns the values of findAll in {{ Name }}Repository`() {
        whenever({{ name }}Repository.findAll())
            .thenReturn(listOf({{ NAME }}_FIXTURE_WITH_ID_1))

        val actual = {{ name }}Service.findAll()

        assertThat(actual).containsExactly({{ NAME }}_FIXTURE_WITH_ID_1)
    }

    @Test
    fun `findAll returns the values of findAll in CommentRepository when filter is empty`() {
        whenever({{ name }}Repository.findAll())
            .thenReturn(listOf({{ NAME }}_FIXTURE_WITH_ID_1))

        val actual = {{ name }}Service.findAll({{#if hasRelations}}{{ Name }}.{{ Name }}FilterInput(){{/if}})

        assertThat(actual).containsExactly({{ NAME }}_FIXTURE_WITH_ID_1)
    }
{{#each fields}}{{#if fieldRelationship}}
    @Test
    fun `findAll delegates to findBy{{FieldName}} when filter only contains {{fieldName}}`() {
        whenever({{ name }}Repository.findBy{{FieldName}}(1))
            .thenReturn(listOf({{ NAME }}_FIXTURE_1))

        val actual = {{ name }}Service.findAll({{ Name }}.{{ Name }}FilterInput({{fieldName}} = 1))

        assertThat(actual).containsExactly({{ NAME }}_FIXTURE_1)
    }
{{/if}}{{/each}}
    @Test
    fun `findById returns the contained value of findById in {{ Name }}Repository if it is non-empty`() {
        whenever({{ name }}Repository.findById(1))
            .thenReturn(Optional.of({{ NAME }}_FIXTURE_WITH_ID_1))

        val actual = {{ name }}Service.findById(1)

        assertThat(actual).isEqualTo({{ NAME }}_FIXTURE_WITH_ID_1)
    }
{{#each fields}}{{#if fieldRelationship}}
    @Test
    fun `findBy{{FieldName}} returns the contents of the corresponding repository call`() {
        whenever({{ name }}Repository.findBy{{ FieldName }}(1))
            .thenReturn(listOf({{ NAME }}_FIXTURE_WITH_ID_1))

        val actual = {{ name }}Service.findBy{{ FieldName }}(1)

        assertThat(actual).isEqualTo(actual)
    }
{{/if}}{{/each}}
    @Test
    fun `findById returns null if findById in {{ Name }}Repository yields an empty Optional`() {
        whenever({{ name }}Repository.findById(1))
            .thenReturn(Optional.empty())

        val actual = {{ name }}Service.findById(1)

        assertThat(actual).isNull()
    }

    @Test
    fun `create calls save on repository if all requirements are met`() {
        whenever({{ name }}Repository.save({{ NAME }}_FIXTURE_1))
            .thenReturn({{ NAME }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if fieldRelationship}}
        whenever({{ fieldType }}Service.findById({{ NAME }}_FIXTURE_WITH_ID_1.{{ fieldName }}))
            .thenReturn({{ FIELD_TYPE }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ name }}Service.create(CREATE_{{ NAME }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ NAME }}_FIXTURE_WITH_ID_1)
    }
{{#if hasRelations}}
    @Test
    fun `create fails when related objects cannot be found`() { {{#each fields}}{{#if fieldRelationship}}
        whenever({{ fieldType }}Service.findById({{ NAME }}_FIXTURE_WITH_ID_1.{{ fieldName }}))
            .thenReturn(null)
{{/if}}{{/each}}
        assertThrows<RuntimeException> {
            {{ name }}Service.create(CREATE_{{ NAME }}_FIXTURE_1)
        }

        verify({{ name }}Repository, times(0)).save({{ NAME }}_FIXTURE_1)
    }
{{/if}}
    @Test
    fun `create publishes a Before{{ Name }}CreatedEvent before saving`() {
        whenever({{ name }}Repository.save({{ NAME }}_FIXTURE_1))
            .thenReturn({{ NAME }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if fieldRelationship}}
        whenever({{ fieldType }}Service.findById({{ NAME }}_FIXTURE_WITH_ID_1.{{ fieldName }}))
            .thenReturn({{ FIELD_TYPE }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ name }}Service.create(CREATE_{{ NAME }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ NAME }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(applicationEventPublisher, {{ name }}Repository)

        inOrder
            .verify(applicationEventPublisher)
            .publishEvent({{ Name }}Event.Before{{ Name }}CreatedEvent({{ name }}Service, {{ NAME }}_FIXTURE_1))
        inOrder
            .verify({{ name }}Repository)
            .save({{ NAME }}_FIXTURE_1)
    }

    @Test
    fun `create publishes an After{{ Name }}CreatedEvent after saving`() {
        whenever({{ name }}Repository.save({{ NAME }}_FIXTURE_1))
            .thenReturn({{ NAME }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if fieldRelationship}}
        whenever({{ fieldType }}Service.findById({{ NAME }}_FIXTURE_WITH_ID_1.{{ fieldName }}))
            .thenReturn({{ FIELD_TYPE }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ name }}Service.create(CREATE_{{ NAME }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ NAME }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(applicationEventPublisher, {{ name }}Repository)

        inOrder
            .verify({{ name }}Repository)
            .save({{ NAME }}_FIXTURE_1)
        inOrder
            .verify(applicationEventPublisher)
            .publishEvent({{ Name }}Event.After{{ Name }}CreatedEvent({{ name }}Service, {{ NAME }}_FIXTURE_WITH_ID_1))
    }

    @Test
    fun `deleteById deletes the {{ Name }} identified by id in the repository`() {
        {{ name }}Service.deleteById(1)

        verify({{ name }}Repository).deleteById(1)
    }

    @Test
    fun `deleteById publishes a Before{{ Name }}DeletedEvent before deletion`() {
        {{ name }}Service.deleteById(1)

        val inOrder = inOrder(applicationEventPublisher, {{ name }}Repository)

        inOrder
            .verify(applicationEventPublisher)
            .publishEvent({{ Name }}Event.Before{{ Name }}DeletedEvent({{ name }}Service, 1))
        inOrder
            .verify({{ name }}Repository)
            .deleteById(1)
    }

    @Test
    fun `deleteById publishes an After{{ Name }}DeletedEvent after deletion`() {
        {{ name }}Service.deleteById(1)

        val inOrder = inOrder(applicationEventPublisher, {{ name }}Repository)

        inOrder
            .verify({{ name }}Repository)
            .deleteById(1)
        inOrder
            .verify(applicationEventPublisher)
            .publishEvent({{ Name }}Event.After{{ Name }}DeletedEvent({{ name }}Service, 1))
    }

}
