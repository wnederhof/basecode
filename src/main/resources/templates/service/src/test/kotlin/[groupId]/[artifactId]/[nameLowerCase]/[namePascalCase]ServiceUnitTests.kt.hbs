package {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}
{{#each fields}}{{#if isFieldRelational}}
import {{ groupId }}.{{ artifactId }}.{{ fieldTypeLowerCase }}.{{ fieldTypePascalCase }}Service{{/if}}{{/each}}
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.{{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1{{#each fields}}{{#if isFieldRelational}}
import {{ groupId }}.{{ artifactId }}.{{ fieldTypeLowerCase }}.{{ fieldTypePascalCase }}Fixtures.{{ fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1{{/if}}{{/each}}
import com.nhaarman.mockitokotlin2.inOrder
import com.nhaarman.mockitokotlin2.times
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.springframework.context.ApplicationEventPublisher{{#if hasRelations}}
import org.junit.jupiter.api.assertThrows
import com.nhaarman.mockitokotlin2.times{{/if}}
import java.util.*

@ExtendWith(MockitoExtension::class)
internal class {{ namePascalCase }}ServiceUnitTests {

    @Mock
    private lateinit var publisher: ApplicationEventPublisher

    @Mock
    private lateinit var {{ nameCamelCase }}Repository: {{ namePascalCase }}Repository
{{#each fields}}{{#if isFieldRelational}}
    @Mock
    private lateinit var {{ fieldTypeCamelCase }}Service: {{ fieldTypePascalCase }}Service
{{/if}}{{/each}}
    @InjectMocks
    private lateinit var {{ nameCamelCase }}Service: {{ namePascalCase }}Service

    @Test
    fun `findAll returns the values of findAll in {{ namePascalCase }}Repository`() {
        whenever({{ nameCamelCase }}Repository.findAll())
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findAll()

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }

    @Test
    fun `findAll returns the values of findAll in CommentRepository when filter is empty`() {
        whenever({{ nameCamelCase }}Repository.findAll())
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findAll({{#if hasRelations}}{{ namePascalCase }}.{{ namePascalCase }}FilterInput(){{/if}})

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{{#each fields}}{{#if isFieldRelational}}
    @Test
    fun `findAll delegates to findBy{{fieldNamePascalCase}} when filter only contains {{fieldNameCamelCase}}`() {
        whenever({{ nameCamelCase }}Repository.findBy{{fieldNamePascalCase}}(1))
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_1))

        val actual = {{ nameCamelCase }}Service.findAll({{ namePascalCase }}.{{ namePascalCase }}FilterInput({{fieldNameCamelCase}} = 1))

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_1)
    }
{{/if}}{{/each}}
    @Test
    fun `findById returns the contained value of findById in {{ namePascalCase }}Repository if it is non-empty`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findById(1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{{#each fields}}{{#if isFieldRelational}}
    @Test
    fun `findBy{{fieldNamePascalCase}} returns the contents of the corresponding repository call`() {
        whenever({{ nameCamelCase }}Repository.findBy{{ fieldNamePascalCase }}(1))
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findBy{{ fieldNamePascalCase }}(1)

        assertThat(actual).isEqualTo(actual)
    }
{{/if}}{{/each}}
    @Test
    fun `findById returns null if findById in {{ namePascalCase }}Repository yields an empty Optional`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.empty())

        val actual = {{ nameCamelCase }}Service.findById(1)

        assertThat(actual).isNull()
    }

    @Test
    fun `create calls save on repository if all requirements are met`() {
        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn({{ fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{{#if hasRelations}}
    @Test
    fun `create fails when related objects cannot be found`() { {{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn(null)
{{/if}}{{/each}}
        assertThrows<RuntimeException> {
            {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)
        }

        verify({{ nameCamelCase }}Repository, times(0)).save({{ nameScreamingSnakeCase }}_FIXTURE_1)
    }
{{/if}}
    @Test
    fun `create publishes an {{ namePascalCase }}CreateEvent after saving`() {
        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn({{ fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .save({{ nameScreamingSnakeCase }}_FIXTURE_1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}CreateEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

    @Test
    fun `update calls save on repository if all requirements are met`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn({{ fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{{#if hasRelations}}
    @Test
    fun `update fails when related objects cannot be found`() { {{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn(null)
{{/if}}{{/each}}
        assertThrows<RuntimeException> {
            {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)
        }

        verify({{ nameCamelCase }}Repository, times(0)).save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{{/if}}
    @Test
    fun `update publishes an {{ namePascalCase }}UpdateEvent after saving`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{#each fields}}{{#if isFieldRelational}}
        whenever({{ fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ fieldNameCamelCase }}))
            .thenReturn({{ fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{{/if}}{{/each}}
        val actual = {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}UpdateEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

    @Test
    fun `deleteById deletes the {{ namePascalCase }} identified by id in the repository if it exists`() {
        whenever({{ nameCamcelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        {{ nameCamelCase }}Service.deleteById(1)

        verify({{ nameCamelCase }}Repository).deleteById(1)
    }

    @Test
    fun `deleteById does not delete the {{ namePascalCase }} identified by id in the repository if it doesn't exist`() {
        whenever({{ nameCamcelCase }}Repository.findById(1))
            .thenReturn(Optional.empty())

        {{ nameCamelCase }}Service.deleteById(1)

        verify({{ nameCamelCase }}Repository, times(0)).deleteById(1)
    }

    @Test
    fun `deleteById publishes an {{ namePascalCase }}DeleteEvent after deletion`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        {{ nameCamelCase }}Service.deleteById(1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .deleteById(1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}DeleteEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

}
