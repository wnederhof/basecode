package {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}
{%for field in fields%}{%if field.isFieldRelational%}
import {{ groupId }}.{{ artifactId }}.{{ field.fieldTypeLowerCase }}.{{ field.fieldTypePascalCase }}Service{%endif%}{%endfor%}
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1
import {{ groupId }}.{{ artifactId }}.{{ nameLowerCase }}.{{ namePascalCase }}Fixtures.{{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1{%for field in fields%}{%if field.isFieldRelational%}
import {{ groupId }}.{{ artifactId }}.{{ field.fieldTypeLowerCase }}.{{ field.fieldTypePascalCase }}Fixtures.{{ field.fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1{%endif%}{%endfor%}
import com.nhaarman.mockitokotlin2.inOrder
import com.nhaarman.mockitokotlin2.times
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.springframework.context.ApplicationEventPublisher{%if hasRelations%}
import org.junit.jupiter.api.assertThrows
import com.nhaarman.mockitokotlin2.times{%endif%}
import java.util.*

@ExtendWith(MockitoExtension::class)
internal class {{ namePascalCase }}ServiceUnitTests {

    @Mock
    private lateinit var publisher: ApplicationEventPublisher

    @Mock
    private lateinit var {{ nameCamelCase }}Repository: {{ namePascalCase }}Repository
{%for field in fields%}{%if field.isFieldRelational%}
    @Mock
    private lateinit var {{ field.fieldTypeCamelCase }}Service: {{ field.fieldTypePascalCase }}Service
{%endif%}{%endfor%}
    @InjectMocks
    private lateinit var {{ nameCamelCase }}Service: {{ namePascalCase }}Service

    @Test
    fun `findAll returns the values of findAll in {{ namePascalCase }}Repository`() {
        whenever({{ nameCamelCase }}Repository.findAll())
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findAll()

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }

    @Test
    fun `findAll returns the values of findAll in CommentRepository when filter is empty`() {
        whenever({{ nameCamelCase }}Repository.findAll())
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findAll({%if hasRelations%}{{ namePascalCase }}.{{ namePascalCase }}FilterInput(){%endif%})

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{%for field in fields%}{%if field.isFieldRelational%}
    @Test
    fun `findAll delegates to findBy{{field.fieldNamePascalCase}} when filter only contains {{field.fieldNameCamelCase}}`() {
        whenever({{ nameCamelCase }}Repository.findBy{{field.fieldNamePascalCase}}(1))
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_1))

        val actual = {{ nameCamelCase }}Service.findAll({{ namePascalCase }}.{{ namePascalCase }}FilterInput({{field.fieldNameCamelCase}} = 1))

        assertThat(actual).containsExactly({{ nameScreamingSnakeCase }}_FIXTURE_1)
    }
{%endif%}{%endfor%}
    @Test
    fun `findById returns the contained value of findById in {{ namePascalCase }}Repository if it is non-empty`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findById(1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{%for field in fields%}{%if field.isFieldRelational%}
    @Test
    fun `findBy{{field.fieldNamePascalCase}} returns the contents of the corresponding repository call`() {
        whenever({{ nameCamelCase }}Repository.findBy{{ field.fieldNamePascalCase }}(1))
            .thenReturn(listOf({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        val actual = {{ nameCamelCase }}Service.findBy{{ field.fieldNamePascalCase }}(1)

        assertThat(actual).isEqualTo(actual)
    }
{%endif%}{%endfor%}
    @Test
    fun `findById returns null if findById in {{ namePascalCase }}Repository yields an empty Optional`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.empty())

        val actual = {{ nameCamelCase }}Service.findById(1)

        assertThat(actual).isNull()
    }

    @Test
    fun `create calls save on repository if all requirements are met`() {
        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%for field in fields%}{%if field.isFieldRelational%}
        whenever({{ field.fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ field.fieldNameCamelCase }}))
            .thenReturn({{ field.fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%endif%}{%endfor%}
        val actual = {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{%if hasRelations%}
    @Test
    fun `create fails when related objects cannot be found`() {
        assertThrows<RuntimeException> {
            {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)
        }

        verify({{ nameCamelCase }}Repository, times(0)).save({{ nameScreamingSnakeCase }}_FIXTURE_1)
    }
{%endif%}
    @Test
    fun `create publishes an {{ namePascalCase }}CreateEvent after saving`() {
        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%for field in fields%}{%if field.isFieldRelational%}
        whenever({{ field.fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ field.fieldNameCamelCase }}))
            .thenReturn({{ field.fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%endif%}{%endfor%}
        val actual = {{ nameCamelCase }}Service.create(CREATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .save({{ nameScreamingSnakeCase }}_FIXTURE_1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}CreateEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

    @Test
    fun `update calls save on repository if all requirements are met`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%for field in fields%}{%if field.isFieldRelational%}
        whenever({{ field.fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ field.fieldNameCamelCase }}))
            .thenReturn({{ field.fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%endif%}{%endfor%}
        val actual = {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{%if hasRelations%}
    @Test
    fun `update fails when related objects cannot be found`() {
        assertThrows<RuntimeException> {
            {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)
        }

        verify({{ nameCamelCase }}Repository, times(0)).save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
    }
{%endif%}
    @Test
    fun `update publishes an {{ namePascalCase }}UpdateEvent after saving`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        whenever({{ nameCamelCase }}Repository.save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
            .thenReturn({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%for field in fields%}{%if field.isFieldRelational%}
        whenever({{ field.fieldTypeCamelCase }}Service.findById({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1.{{ field.fieldNameCamelCase }}))
            .thenReturn({{ field.fieldTypeScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
{%endif%}{%endfor%}
        val actual = {{ nameCamelCase }}Service.update(1, UPDATE_{{ nameScreamingSnakeCase }}_FIXTURE_1)

        assertThat(actual).isEqualTo({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .save({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}UpdateEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

    @Test
    fun `deleteById deletes the {{ namePascalCase }} identified by id in the repository if it exists`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        {{ nameCamelCase }}Service.deleteById(1)

        verify({{ nameCamelCase }}Repository).deleteById(1)
    }

    @Test
    fun `deleteById does not delete the {{ namePascalCase }} identified by id in the repository if it doesn't exist`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.empty())

        {{ nameCamelCase }}Service.deleteById(1)

        verify({{ nameCamelCase }}Repository, times(0)).deleteById(1)
    }

    @Test
    fun `deleteById publishes an {{ namePascalCase }}DeleteEvent after deletion`() {
        whenever({{ nameCamelCase }}Repository.findById(1))
            .thenReturn(Optional.of({{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))

        {{ nameCamelCase }}Service.deleteById(1)

        val inOrder = inOrder(publisher, {{ nameCamelCase }}Repository)

        inOrder
            .verify({{ nameCamelCase }}Repository)
            .deleteById(1)
        inOrder
            .verify(publisher)
            .publishEvent({{ namePascalCase }}Event.{{ namePascalCase }}DeleteEvent({{ nameCamelCase }}Service, {{ nameScreamingSnakeCase }}_FIXTURE_WITH_ID_1))
    }

}
