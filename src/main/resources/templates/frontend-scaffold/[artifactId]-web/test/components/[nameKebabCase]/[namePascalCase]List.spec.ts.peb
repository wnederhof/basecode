import { shallowMount, createLocalVue, RouterLinkStub, Wrapper } from '@vue/test-utils'
import {{namePascalCase}}List from '@/components/{{nameKebabCase}}/{{namePascalCase}}List.vue'
import gql from 'graphql-tag'
import anything = jasmine.anything;

const localVue = createLocalVue()

describe('{{namePascalCase}}List', () => {
  let wrapper: Wrapper<any>
  let mutate: jest.Mock

  const createComponent = (props: any) => {
    mutate = jest.fn()

    wrapper = shallowMount({{namePascalCase}}List, {
      localVue,
      propsData: props,
      stubs: {
        NLink: RouterLinkStub,
        VLoadingIndicator: true,
        VErrorMessage: true,
        {{namePascalCase}}List: true,
        {{namePascalCase}}Editor: true,
        $id: true
      },
      mocks: {
        $apollo: {
          mutate,
          queries: {
            loading: false,
          }
        }
      }
    })
  }

  afterEach(() => {
    wrapper.destroy()
  })

  it('is a Vue instance', () => {
    createComponent({})
    expect(wrapper.vm).toBeTruthy()
  })

  it('has no modal when instantiated', () => {
    createComponent({})

    expect(wrapper.vm.{{ nameCamelCase }}EditorVisible).toBe(false)
  })

  it('has modalTitle "Edit {{ namePascalCase }}" and visible modal when edit{{ namePascalCase }} is called', () => {
    createComponent({})
    wrapper.vm.edit{{ namePascalCase }}(1)

    expect(wrapper.vm.modalTitle).toBe("Edit {{ namePascalCase }}")
    expect(wrapper.vm.{{ nameCamelCase }}EditorVisible).toBe(true)
  })

  it('has modalTitle "New {{ namePascalCase }}" and visible modal when new{{ namePascalCase }} is called', () => {
    createComponent({})

    wrapper.vm.new{{ namePascalCase }}()
    expect(wrapper.vm.modalTitle).toBe("New {{ namePascalCase }}")
    expect(wrapper.vm.{{ nameCamelCase }}EditorVisible).toBe(true)
  })


  it('closes the modal when closeEditor is called', () => {
    createComponent({})
    wrapper.vm.edit{{ namePascalCase }}(1)
    wrapper.vm.closeEditor()

    expect(wrapper.vm.{{ nameCamelCase }}EditorVisible).toBe(false)
  })

  it('mutates when delete{{ namePascalCase }} is called and confirmed', async () => {
    createComponent({})
    const queryHandler = jest.fn().mockResolvedValue(true)
    global.confirm = () => true

    await wrapper.vm.delete{{ namePascalCase }}(1)

    expect(mutate).toBeCalledTimes(1)

    expect(mutate).toBeCalledWith({
      mutation: gql`mutation delete{{ namePascalCase }}($id: ID!) {
        delete{{ namePascalCase }}(id: $id)
      }`,
      variables: { id: 1 },
      update: anything()
    })
  })

  it('doesnt mutate when delete{{ namePascalCase }} is called and not confirmed', async () => {
    createComponent({})
    const queryHandler = jest.fn().mockResolvedValue(true)
    global.confirm = () => false

    await wrapper.vm.delete{{ namePascalCase }}(1)

    expect(mutate).toBeCalledTimes(0)
  })
{%for field in fields%}{%if field.isFieldRelational%}
  it('shows {{ field.fieldNameCamelCase }} if this is not passed as a prop', async () => {
    createComponent({})
    expect(wrapper.vm.fields.filter((el: any) => el.key === '{{ field.fieldNameCamelCase }}')).toHaveLength(2)
  })

  it('doesnt show {{ field.fieldNameCamelCase }} if this is passed as a prop', async () => {
    createComponent({ {{ field.fieldNameCamelCase }}: 1 })
    expect(wrapper.vm.fields.filter((el: any) => el.key === '{{ field.fieldNameCamelCase }}')).toHaveLength(0)
  })
{%endif%}{%endfor%}
})
